

\lhead[]{}
\rhead[]{}
\chead[BDDの理論的背景]{BDDの理論的背景}

# BDDの理論的背景

本稿では、振る舞い駆動開発(Behavior Driven Development:BDD)について、テスト駆動開発(TDD)の生い立ちからBDDの発端までを辿ることで、BDDの理論的背景を明らかにするものです。

## TDDの憂鬱

TDDとは、プログラミングする過程の中に細かいサイクルで、自動化されたテストを組み込むとどのような開発プロセスが生まれるかといういうケント・ベック氏の思考実験と現場での実践から生まれた開発プロセスです。[@Beck2002]その意味を含めて、本稿ではTDDを「プログラミングとテストすることを工程として統合する開発スタイル」と定義します。

その中ではTDDで作成されるテストというのは、関数なり、メソッドなり、プログラムを実行する最小単位に対するテストである、いわゆる「ユニットテスト」であることを暗黙な前提として述べられています。

もともと関数やメソッドごとに、例えばC言語であればmain関数をエントリーポイントとして設けるというデバッグ手法は、動作確認を行うという熟練したプログラマーによって以前から行われていたプラクティスです。プログラムによって自動化されたユニットテストというのは、その手法を、フレームワークとしてパターン化したところというところに価値がありました。

プログラムを作成したプログラマー自らの手によって、徹底したデバッグと「容赦ないテスト」 [@Thomas2000] が行われ、バグが取り除かれたプログラム部品が提供されるということは、プログラムのモジュールをボトムアップで組み合わせ、システムとして結合する上で、結合フェーズでのバグの発見による手戻りを減らすという効果があります。

しかしながら、ユニットテストで確認される仕様というのは、ユーザーが画面等のユーザーインターフェースを通じて操作した結果としての振る舞いや、その上で実現されるワークフローのあるべき姿から導出されるものです。そして、ユニットテストでプログラムの振る舞いを確認したとしても、それはシステムとしての振る舞いや、ワークフローの正しさを確認することはできません。

にもかかわらず、ユニットテストとプログラミングの間を交互に行き来することによってプログラムの骨格を作っていくTDDという開発スタイルのインパクトがもたらすものは強烈です。そのインパクトは、TDDによるユニットテストのみでアプリケーションが動作に耐えうるだけの品質を担保できるという錯覚と誤解を生み出します。その結果として、成果物の受入工程においてステークホルダー間の齟齬を生み出すことになりました。



そのことを批判する論陣の先頭に立つのが、ソフトウェアパターンのコミュニティーにおいて初期から中心的な役割をつとめ、「Cope」として知られる、Jim Coplien氏です。氏のそのような主張は、「Why Most Unit Testing is Waste」という論文[@Coplien2014]にもっと色よく現れています。また、「DHH」として知られるRuby on Railsの作者、デイヴィッド・ハイネマイヤー・ハンソン氏の「TDD is dead. Long live testing.」[@Hansson2014]のエントリーは、さまざまな議論を呼び起こしました。

アジャイル開発において、「『完了』とは完了のことだ」というイディオムがありますが、TDDによるテストのみで、プロダクトの開発が完了したことにならないのは確かです。


Burak Turhan氏、Lucas Layman氏、Madeline Diep氏、Hakan Erdogmus氏、Forrest Shull氏は「Making Software」[@Oram2011]の中で、TDDについて、オンラインデータベースと科学刊行物でのエビデンスを対象にTDDの効果測定を試みています。そこでは、

> TDDの効果については、まだ多数の未知な事柄があります。実際、私たちが測定したどの指標についても、つまり内部品質、外部品質、生産性、テスト品質のどれについても、TDD効果にかんしてはエビデンスが一貫していないことは明白です。

と結論づけています。


TDDの目指すところは、ベック氏の「動作するきれいなコード」[Beck2002]という言葉にあらわれるように、動作するコードが動作する、ということにあります。

その点において、TDDの歴史は、「テストはしたが動作しないプログラム」を生み出してしまうという本質的に内在した弱点を克服するための改善の繰り返しの歴史でもありました。

## メソッドベースのテストとシナリオベースのテスト

TDDの問題点の一つとして、最もシンプルな形式であるオブジェクトのメソッド(引数)の呼び出しに対してテストを記述した場合に、エンドユーザーからのユースケースに従って順を追って呼び出された時の実際の呼び出しシーケンスと、テストからの呼び出しシーケンスが乖離するというものがあります。このことにTDDの普及期から取り組んだのが、1990年代後半から2000年代前半にかけて日本におけるオブジェクト指向開発とテスト駆動開発における論陣をリードした、故石井勝(まさーる)氏^[2005年4月、JR福知山線脱線事故にて逝去]です。

石井氏が生前Webサイトで公開していた内容は、現在オブラブ ^[[http://objectclub.jp/](http://objectclub.jp/)]がメンテナンスを引き継いで公開されています ^[[http://objectclub.jp/community/memorial/homepage3.nifty.com/masarl/](http://objectclub.jp/community/memorial/homepage3.nifty.com/masarl/)]。

石井氏は、「JUnit 実践講座 - シナリオベースのテストケースの書き方」[@Ishii2002]^[[http://objectclub.jp/community/memorial/homepage3.nifty.com/masarl/article/junit/scenario-based-testcase.html](http://objectclub.jp/community/memorial/homepage3.nifty.com/masarl/article/junit/scenario-based-testcase.html)]で、テストケースを二つの枠に分類しています。テストするクラスのメソッドをもとにメソッドを作成するメソッドベースのテストと、テストするクラスのシナリオを元にメソッドを作成するシナリオベースのテストの二つです。

メソッドベースのテストとシナリオベースのテストの分類では、データを保持するのを目的とするクラスやユーティリティ的なクラスにはメソッドベースを起こし、クラスの振る舞いにバリエーションがあるクラスは、テストパターンに応じてクラスのユースケースのシナリオを起こすシナリオベースのテスト記述を紹介しています。

石井氏の論陣は、当然当時のオブジェクト指向に関する世間の議論をベースとしていますから、ドメイン駆動設計(DDD)に代表されるその後のアプリケーションの設計に関する知見を取り込むことは出来ていませんが、それでもユニットテストの自動化を考えるにあたって、テストケースをどう構造化するかということに取り組んだ先達であり、その着眼点の鋭さは今日でも目を見はるものがあります。

## BDD

イギリスのコンサルタントであるDan North氏は2003年、JUnitとTDDの影響を受けて、JBehave^[[http://jbehave.org/](http://jbehave.org/)]というテスティングフレームワークの開発を始めます。その中で見いだした開発スタイルにBDD(behavior driven development)と命名し、その普及と啓蒙にあたるようになりました。

North氏によるBDDの出発点は、テストメソッドのメソッド名を、テストに対するドキュメンテーションとして使用するものです。これはNorth氏の同僚であるChris Stevenson氏が作成したagiledox ^[[http://agiledox.sourceforge.net/](http://agiledox.sourceforge.net/)]というユーティリティーに発想を得たものです。ここからユニットテストのテストは、メソッド(関数)をテストするための治具という位置づけから発展し、ソフトウェアの仕様を記述するためのドキュメントとしての位置づけを得るようになります。

例えばEclipseでJUnitによるテストを実行した場合、テストの結果は以下の様に表示されます。この際の「test1」「test2」というテストの名称は 、JUnitの場合、\@Testアノテーションを付与されたメソッドの名称から作成されています。([@lst:020_code1]  [@fig:020_a_image])



```{#lst:020_code1 caption="テストケースを表現しない場合のテストコード"}
	@Test
	public void test1() {
		assertThat(FizzBuzz.convert(1), is("1"));
	}

	@Test
	public void test2() {
		assertThat(FizzBuzz.convert(2), is("2"));
	}
```

![テスト結果の表示(テストケースを表現していない場合)](src/img/test1.png){#fig:020_a_image}

これを、テストのメソッド名を以下の様にすることで、レポート上に、実行したテストの仕様が表現できるようになります。([@lst:020_code2]  [@fig:020_b_image])

```{#lst:020_code2 caption="テストケースを表現する場合のテストコード"}
	@Test
	public void _1を渡したら文字列1を返すべき() {
		assertThat(FizzBuzz.convert(1), is("1"));
	}

	@Test
	public void _2を渡したら文字列2を返すべき() {
		assertThat(FizzBuzz.convert(2), is("2"));
	}
```

![テスト結果の表示(テストケースを表現している場合)](src/img/test2.png){#fig:020_b_image}

North氏は、ここを出発点にして、対象となる「振る舞い」(behavior)をテストから導出するという、BDDのスタイルをかたち作っていきます。そのエッセンスは、彼のサイトで公開されている「Introducing BDD」^[[https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/)] のエントリーで記されています。^[日本語訳は和智右桂氏によって公開されています。[http://d.hatena.ne.jp/digitalsoul/20090819/1250686015](http://d.hatena.ne.jp/digitalsoul/20090819/1250686015) ]

## should「べき」

テストメソッドの名前でテストの仕様を記述するとなった時に、次に考えることはそのテストが「何を」テストするのかということです。ここでNorth氏は、テストメソッドは「should」という単語で始めるという制約を設けることで、テストの対象となるものを明らかにする発想に至ります。

> この時に、テストメソッドは「should」という単語で始めなければならないという規約が浮かびました。この文章テンプレート、すなわちそのクラスが何かをするべきだという文章テンプレートが意味しているのは、現在対象となっているクラスに対するテストしか定義できないということです。

テストメソッドの名称に「should」という語彙を与えることによって、対象となるクラスがどう振る舞うべきかをテストが担う役割として明確になるというのは、TDD、そしてユニットテストに対する知見が蓄積された今日では至極当然のことに見えます。しかし、ユニットテストという物が登場した当時、そもそも対象となるクラスとテストクラスが1対1で記述するスタイル(Testcase class per Class)と、アプリケーションの機能単位(Testcase class per Feature)に記述するスタイルをどう使い分けるのかということも明確でなかった時点で、North氏がテストの文脈に"should"という語彙を持ち込んだことは大きなインパクトがありました。

## 実行可能な仕様

RSpecは Steven Baker氏 Dave Astels氏、 Aslak Hellesøy氏、 David Chelimsky氏とともに2005年に開発をはじめたruby向けのテスティングフレームワークです。RSpecの特徴は、テストの記述をrubyを用いて言語内DSLとして記述することにあります。もともとrubyコミュニティーでは、タスクツールであるRakeをはじまりに、ブロック構文やメタプログラミングなどのrubyの言語機能を生かして言語内DSLでツールを記述する文化があります。


言語内DSLの特徴を最大限に生かしたのがWebアプリケーションフレームワークであるRuby on Railsですが、North氏が発案したBDDの思想は、ここで言語内DSLというフォーマットを得ることにより、「実行可能な仕様」(Executable specification)という方向を目指すことになります。

## Outside-in , Inside-out

ここで話は一度TDDの話に戻ります。カナダのアジャイルソフトウェア開発の第一人者であるGerard Meszaros氏は2007年、「xUnit Test Patterns」[@Meszaros2007]という書籍を出版します。この本はユニットテストの規模が大きくなるにつれて陥りがちなアンチパターンとその対処、フレームワークとしての紹介とその上でテストを組織化する方法について余すところなくパターン化とした大作の書籍ですが、この中でテストコードの構造化について、「Outside-in」と「Inside-out」という視野を導入しています。

ユニットテストとプログラミングの関係を考えた場合、最もオーソドックスなのは、プログラムの個々の部品となるモジュールからテストと共にプログラムを作成し、完成した個々の部品を結合して、上位レベルのプログラム部品を作成し、最終的にプログラム全体への完成へとつなげるものです。このボトムアップのアプローチを「Inside-out」と呼びます。

これに対し、ユーザインターフェースやAPIのエンドポイントに近い層からプログラミングを始め、依存先となる下位のプログラム部品はTest Doubleと呼ばれるダミーのモジュール^[いわゆる「モック」に対する語法に対しては、[@Goyoki2012][http://goyoki.hatenablog.com/entry/20120301/1330608789](http://goyoki.hatenablog.com/entry/20120301/1330608789) 参照]を配置して、インターフェースによる呼び出しをモックした状態でプログラミングを行い、そこから下位レベルとなる依存先のプログラム部品へとプログラミングを進めていくトップダウンのアプローチを、「xUnit Test Patternes」では「Outside-in」と呼んでいます。

「Inside-out」と「Outside-in」のアプローチには両方に長所と短所があり、どちらか片方がもう一方を置き換えるという立場にあるものではありません。重要なのは、双方のアプローチが相互を補完する関係にあるということです。「Inside-out」には「ユニットテストした部品同士を結合するとインターフェース不整合などの問題が起きて動かない」「対向になるプログラム部品が完成しないとプログラミングが進まない」という問題があります。それに対して「Outside-in」には、プログラム部品相互のインターフェースを最初に定義した上で、トップダウンでプログラミングを進められるという利点がありますが、「Test Double」は実際の結合相手になる本物のオブジェクトの振る舞いを全て再現できるわけではないという問題があります。この二つのアプローチを組み合わせたことで、TDDによって書かれるユニットテストが、個々のプログラム部品レベルでの品質と、結合した上でのソフトウェアの品質両方に寄与できるということをMeszaros氏は示しています。

## 「内側と外側のフィードバックループ」  

さらにその後の2009年、英国のITコンサルタント Steve Freeman氏とNat Pryce氏は「Growing Object-Oriented Software, Guided by Tests」[@Freeman2010]^[邦訳「実践テスト駆動開発 テストに導かれてオブジェクト指向ソフトウェアを育てる」]という書籍を出版します。この本の根底を貫いているコンセプトに「内側と外側のフィードバックループ」というものがあります。

伝統的なTDDでは、失敗するテストを書くところからサイクルをはじめます。次にテストを通るようにし、リファクタリングするところまでを一つのサイクルとし、それを繰り返していきます。

Freeman氏とPryce氏は、この外側に、まず失敗する受け入れテストを書くことから始まるサイクルを加えます。そしてエンドツーエンドで書かれる外側の受入テストのサイクルは進捗を計測するテストとして、そしてユニットテストとして書かれるテストはリグレッションを検出するテストとして、二重のフィードバックループを構築します。

そしてテストと品質の関係を、「外側の質と内側の質」として定義しました。

> すなわち、外側のシステムが顧客やユーザーのニーズ(機能を備えているか、信頼できるか。利用できるか、素早く反応するか、などなど)にどれくらい応えられているかということであり、内側の質とは開発者や管理者のニーズ(理解しやすいか、変更は容易か、など)にどれくらい応えられているかということである

ここで重要なのは、外側の質と内側の質との相互関係です。外側の質によって顧客に価値を提供できるからこそ、内側の質を支えるテストはソフトウェア開発の工程として存在する正当性を獲得することができます。そしてユニットテストによって内側の質が確保され、変更に耐えうるだけの堅牢なソフトウェアが存在するからこそ、外側の質は継続的に価値を提供することができます。

Freeman氏とPryce氏は、「外側の質を保ちつつ内側の質を、内側の質を保ち外側の質をあげる」^[[@Freeman2010]の日本語訳版での和田卓人氏の言]という、熟練したプログラマーが有していた暗黙知を言語化しました。このことによって、ソフトウェアが提供する価値を確認するためのループと、プログラマーがプログラムを作成することのループがつながったことにより、TDDのテストは、ソフトウェア、ひいてはサービスをデリバリーするための一連の流れの中での必須のプロセスという位置づけを得て、次のステップへとすすむことになります。

## 分析のためのユビキタスランゲージ

TDDを巡る議論の中で、複数のフィードバックループを組み合わせる形で、ソフトウェアをデリバリーするまでの開発のフローをカバーできる範囲を広げていく流れが生まれたきたことがわかります。

BDDは、ステークホルダーがソフトウェア開発を通じた成果物を受け取る際の条件をテストの形式で表現することを出発点とすることで、外側のフィードバックからソフトウェア開発を駆動することを目指してきました。その中でBDDは、ソフトウェアを使用するユーザー側と、開発チームの間が、共通の語彙を用いて、受入条件について議論し、同意するための分析プロセスを構築すること目指してきました。

North氏は、「Introducing BDD」の中で、受入条件を表現するためのシナリオのフォーマットを「Given When Then」の形式で示し、それを「分析のためのユビキタスランゲージ」としています。その点に於いて、BDDで記述される仕様というのは、ドメイン駆動設計(DDD)でよって描かれるビジネスドメインの世界を、テストという観点から描き直したものと捉えることができます。

## Given When Then

- Cucumber
- Human Readableなテスト仕様
- ソフトウェア要求と実装の間のトレーサービリティー

## 何がためのBDD

ここまで、ソフトウェア開発者のコミュニティーの中でBDDという概念が生まれ、それが定着するまでの間に、TDDに代表されるユニットテストの技法の中で、複数のフィードバックループを組み合わせることで、開発プロセスを改善し、信頼に耐えうる品質のソフトウェアを生み出す発想が並行して生まれ、今日に至っていることを示してきました。

ここで、ソフトウェアをデリバリーするためのフィードバックループを段階を踏んで外側に広げていきます。その時に、もっとも外側に来るループは、そのソフトウェアが駆動する開発主体の生業を通じて、社会に対してどのような作用を及ぼすかであり、ビジネスとして捉えるなら収益性と持続性です。

であるがゆえに「Specification by Example」[@Adzic2011]の著者であるGojko Adzic氏はソフトウェアがもたらす変化とその目指すゴールを「WHO(誰が)」「HOW(どのように)」「WHAT(何を)」という3つの軸から切り込んでいく「インパクトマッピング」という手法を提唱しています。[Adzic2012]

また、John Ferguson Smart氏は「BDD in Action」[@Smart2015]の中でソフトウェア開発がまず目指すものに対して「Show me the money」と言い切ります。



仕様を実行可能な形式で記述することから出発して、サービスを通じて何を実現するか、誰を対象にしているか、どののようなソフトウェアを開発するか、そしてどのようにソフトウェアを実装しているかということをシームレスに連携するかを目指しているかと言うことがわかります。

TDDの「テストはしたが要求通り動作しないソフトウェアを作り出す」、という欠点を克服するため、BDDは、テストケースの名称で対象の振る舞いを記述する、という出発点から、要求とソフトウェア実装の間のトレーサビリティーを確保しつつ、段階的にソフトウェアの開発を進めていく、という方向に進化を進めて来ました。

その点において、BDDとは、TDDを成功に導いてきた実践者が行ってきた要点をより強調する形で、方式化したものであると言えます。[Smart2015]
