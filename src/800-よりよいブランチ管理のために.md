\lhead[]{}
\rhead[]{}
\chead[ よりよいブランチ管理のために]{よりよいブランチ管理のために}

#よりよいブランチ管理のために

本稿は、サービス開発の中で、フィードバックサイクルの短縮とリリース管理の最適化に寄与するバージョン管理を目指すため、ブランチ管理に対し留意すべきことをまとめたものです。

例示に使うバージョン管理システムとしてはGitを念頭に置いています。Gitを用いたブランチ管理については、様々なモデルが提唱されていますが、本稿ではVincent Driessen氏が提唱したgit-flowを前提として議論を進めます。

- A successful Git branching model [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/)
- 日本語訳 [http://qiita.com/homhom44/items/9f13c646fa2619ae63d0](http://qiita.com/homhom44/items/9f13c646fa2619ae63d0)
- アトラシアン社による解説 [https://www.atlassian.com/ja/git/workflows#!workflow-gitflow](https://www.atlassian.com/ja/git/workflows#!workflow-gitflow)

##「そのブランチはどの環境にデプロイされますか？」

ブランチを用いて開発を進める中で、日々のタスクに応じて作成されたfeatureブランチ、ないしfeatureブランチから作成された作業用のブランチは、工程の進捗に応じて、developブランチ、releaseブランチ、masterブランチにマージされていきます。

この際に、それぞれのブランチがビルドされた後、どの環境にデプロイされて、検証の用途に共用されるかが明確でない場合があります。このことは、ブランチの性格を不明確にし、ワークフローの運用を不確実なものにします。

git-flowのブランチモデルを採用している現場で散見するのは、本番環境にリリースされるreleaseブランチと新しいフィーチャーが追加されるfeatureブランチの間で、developブランチの位置づけが不明確になるものです。

各々のブランチ、特に開発の進捗に応じて複数作成されるfeatureブランチでは、クラウドサービスや、Docker等の仮想化基盤を使用して、ブランチごとに固有のエンドポイントを持った検証用の環境を作成することが理想です。

ですが、実際のサービス開発の現場では、サーバー等のリソースの調達の都合上、一つのサーバー環境を複数のブランチをデプロイするために使い回すような場合があります。

この際に留意すべきは、デプロイされるブランチを切り替える際に、切り替え前のデプロイされていたアプリケーションが、リソースファイル等をサーバー上に残して、機能上の妨げとならないようにすることです。ビルドスクリプトや、デプロイスクリプトの中で、サーバー上のデプロイ前の状態に関わりなく、任意のブランチがデプロイできるよう、スクリプトの実装で配慮することが必要になります。


##「上流が変更されたら下流ブランチは変更を取り込む」

ブランチ管理に見られるアンチパターンとして、featureブランチ等の機能の開発される作業の下流のブランチで作業の完結までに時間がかかり、ブランチがなかなかマージされないという問題があります。この場合、masterブランチ等の上流(upstream)になるブランチとの差分が時間の経過とともに大きくなるため、最終的にマージを行う際に修正に時間のかかるコンフリクトが発生し、マージを行うタイミングがさらに後ろにずれていきます。

Brad Appleto氏がまとめた、The ACME Project(Assembling Configuration Management Environments) ^[[http://www.bradapp.com/acme/](http://www.bradapp.com/acme/)] では、並行開発におけるブランチ管理のアンチパターンとして、ブランチが、特定の機能や修正のための目的を持つことなく、進行中のワークスペースのように使用されることを指して、The Never-ending Branchと表現しています。^[[http://www.bradapp.com/acme/branching/pitfalls.html#NeverEndingBranch](http://www.bradapp.com/acme/branching/pitfalls.html#NeverEndingBranch)]

このことを避けるためには、下流のブランチを持つ役割を明確にし、なるべくブランチ上で開発が進む期間を短期間にする必要があります。ですが、プロジェクトでの進行上の理由で、特にdevelopブランチの直下のfeatureブランチについては、ブランチが存続する期間が長くなる場合があります。

この場合、上流のブランチと下流のブランチで相互にマージを行い、ブランチの内容の同期を適宜行う必要があります。

「リーン開発の現場」[@Kniberg2011]では、複数チームでの複数機能の並行開発を進める上で、上流ブランチと下流ブランチの同期をどのようにとるかについて、以下のように述べています。

>	・トランクからチームブランチにマージする(この日に他のチームがトランクを更新している場合に備えて)
>
>	・チームブランチが安定していることの最終確認を行う(つまり、システムテスト準備OKになっているかを確かめる)
>
>	・チームブランチをトランクにマージする。
>
> ここまでくれば、チームブランチとトランクは、同じコードを正しく取り込んだ状態になるんだ！開発者がチームブランチに新しい変更をコミットするまでの間、この一瞬の美しさは持続する。

「リーン開発の現場」の事例では、バージョン管理システムとして、IBM製品であるClearCaseが使われていましたが、Git等の分散型バージョン管理でもこの原則は同じです。

Git-flowをはじめとしていかなるブランチモデルでも、その根底には上流から下流へ、下流から上流へ、その変更はツリー上に相互に伝播していくこと、そして「上流のブランチが更新された時に、下流はその変更を受け取る」という原則があります。

Gitを使用した開発の特徴として、優れたマージ機能を生かした、プルリクエスト等のブランチを活用したワークフローがあります。その特徴と強みをいかすためには、マージを行う際のチェンジセットの大きさを一定の範囲に限定し、マージのためのコストが増大しないようにすることが必要です。

Gitのブランチは個々のコミットの集合体ですが、サービス開発を進める上では、最終的にmasterブランチにマージされ、リリースされる一点を目指して、ブランチのツリーが収束していくような形を目指していくことになります。その中で、ブランチ間のマージのコストと、コンフリクト等によるリスクを最小限にするためには、隣接するブランチ同士が相互にマージを行い、ブランチ間の差分を一定範囲にとどめることが必要になります。

## 「クリーントランク」

ここまで述べたマージ戦略を実現する上では、マージ元となる上流ブランチのビルドがパスする状態にあり、ビルドがクリーンであることは、非常に重要です。上流ブランチをマージする際、上流ブランチにコンパイルエラー等のビルドエラーが存在していること等を理由として、マージに時間がかかるような状態が発生すると、ブランチ管理の生産性を著しく低下させます。

その状態の行き着く先が、「ブランチをマージするのに一日かかる」「マージをするのに徹夜」というような、バージョン管理が逆にチーム開発の円滑な進行を阻害しているような状態です。

継続的インテーグレーション(CI)などを活用して、上流ブランチのビルドがクリーンな状態を維持することが求められます。

この際に留意すべきは、リリース手順として、ステージング環境にリリースした成果物(Artifact)をそのまま本番環境にリリースするワークフローの場合、masterブランチにマージが行われるのは本番環境へのデプロイが完了し、リリースが完了した後になることです。このため、最上流であるmasterブランチのビルドがクリーンであることが意外と見逃されがちです。

## 「使い終わったブランチは片付けなさいって言ったでしょ！」

ブランチをマージする際にプルリクエストを用いてコードレビューを行う際には、GitHubやBitbucket等のソースコードのホスティングサービスの機能によって、レビュー完了時にマージ元のブランチを削除することができます。ですが、サービス開発の現場においては、開発チーム内のコードレビューが完了するタイミングと、品質保証のためのテストを担当するチームで受入テストが行われるタイミングのずれがある場合があります。この場合、プルリクエストがマージされたことが、ブランチを作成する起点となるチケット作業工程の完了(クローズ)を意味しないため、ブランチを削除しない場合があります。

この場合、ブランチを削除するタイミングについては、上位ブランチのいずれかのブランチがマージされたタイミングで行うことになりますが、遅くとも、リリースが完了し、masterブランチでのマージが行われた状態で、役割を追えたブランチは削除されることになります。

このようにブランチの整理を行わない場合、上流と下流ブランチの間で、相互にマージを行う際、下流側のマージの対象となるブランチの把握が煩雑になるため、マージに関する作業効率の低下や、マージ作業の漏れを発生させる原因となります。

また、ビルドスクリプト等のファイルは、修正を行った際に、現在開発が進行中の全てのブランチにマージを展開するべきですが、開発が終了しているブランチが複数存在しているような状況では、展開をスムーズに行う事が難しくなります。

このため、リリースが完了したなどのタイミングで、定期的に、役割を終えたブランチを削除することが必要になります。

Gitでは、以下のようなコマンドを実行することにより、現在チェックアウトしているブランチにマージ済みのブランチ、マージされていないブランチの一覧を出力することができます。[@lst:800_code1]  


```{#lst:800_code1 caption="マージ済みのブランチを表示する操作例"}
> git checkout master
> # リモートの削除済みのブランチを反映する
>  git fetch --prune
> # マージ済みのブランチを表示する
> git branch -a --merged
* master
  merged-branch
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/merged-branch
```


```{#lst:800_code2 caption="未マージのブランチを表示する操作例"}
> git checkout master
> # リモートの削除済みのブランチを反映する
>  git fetch --prune
> # マージされてないブランチを表示する
> git branch -a --no-merged
  no-merged-branch
  remotes/origin/no-merged-branch
```
この出力をもとにスクリプトを組み立てるなどして、ブランチの削除処理を行う事になります。

## まとめ

サービス開発の中での、ブランチ管理に対し留意すべきことをまとめました。リリース頻度やチーム構成により、最適なブランチ管理のモデルはかわってきますが、ブランチの上流から下流へ、下流から上流へ、変更がツリー上に相互に伝播していくことはかわらないポイントとなってきますので、本稿で書いた内容がみなさんの構成管理の参考になれば幸いです。



